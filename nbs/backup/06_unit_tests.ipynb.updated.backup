{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1be0340e",
   "metadata": {},
   "outputs": [],
   "source": [
    "#default_exp tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6cb512a",
   "metadata": {},
   "outputs": [],
   "source": [
    "#hide\n",
    "import sys\n",
    "sys.path.append(\"..\")\n",
    "import json\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "from tensorflow.keras.models import Model\n",
    "import unittest\n",
    "import tempfile\n",
    "import os\n",
    "import gym\n",
    "from deap import base, creator, tools\n",
    "import optuna\n",
    "\n",
    "from dpct.individual import DHPCTIndividual\n",
    "from dpct.evolver import DHPCTEvolver\n",
    "from dpct.optimizer import DHPCTOptimizer"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "275c8c4f",
   "metadata": {},
   "source": [
    "# Unit Tests\n",
    "\n",
    "> Comprehensive tests for the DPCT library components."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5e421ac4",
   "metadata": {},
   "source": [
    "## DHPCTIndividual Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f7e478de",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTIndividual(unittest.TestCase):\n",
    "    \"\"\"Test cases for DHPCTIndividual class\"\"\"\n",
    "    \n",
    "    def setUp(self):\n",
    "        \"\"\"Set up test fixtures\"\"\"\n",
    "        self.individual = DHPCTIndividual(\n",
    "            env_name=\"TestEnv\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={},\n",
    "            levels=[\n",
    "                {'units': 10},\n",
    "                {'units': 5}\n",
    "            ],\n",
    "            activation_funcs=['relu', 'tanh'],\n",
    "            weight_types=['glorot_uniform', 'glorot_uniform']\n",
    "        )\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        \"\"\"Test proper initialization of DHPCTIndividual\"\"\"\n",
    "        self.assertEqual(self.individual.env_name, \"TestEnv\")\n",
    "        self.assertEqual(self.individual.gym_name, \"CartPole-v1\")\n",
    "        self.assertEqual(len(self.individual.levels), 2)\n",
    "        self.assertEqual(len(self.individual.activation_funcs), 2)\n",
    "        self.assertEqual(len(self.individual.weight_types), 2)\n",
    "        self.assertIsNone(self.individual.env)\n",
    "        self.assertIsNone(self.individual.model)\n",
    "    \n",
    "    def test_compile(self):\n",
    "        \"\"\"Test compilation of the individual's model\"\"\"\n",
    "        self.individual.compile()\n",
    "        self.assertIsNotNone(self.individual.env)\n",
    "        self.assertIsNotNone(self.individual.model)\n",
    "        self.assertIsInstance(self.individual.model, Model)\n",
    "    \n",
    "    def test_config(self):\n",
    "        \"\"\"Test config method returns correct configuration\"\"\"\n",
    "        config = self.individual.config()\n",
    "        self.assertEqual(config['env_name'], \"TestEnv\")\n",
    "        self.assertEqual(config['gym_name'], \"CartPole-v1\")\n",
    "        self.assertEqual(len(config['levels']), 2)\n",
    "        self.assertEqual(config['levels'][0]['units'], 10)\n",
    "        self.assertEqual(config['levels'][1]['units'], 5)\n",
    "    \n",
    "    def test_save_load_config(self):\n",
    "        \"\"\"Test saving and loading configuration\"\"\"\n",
    "        with tempfile.NamedTemporaryFile(suffix='.json', delete=False) as tmp_file:\n",
    "            config_path = tmp_file.name\n",
    "            \n",
    "        try:\n",
    "            self.individual.save_config(config_path)\n",
    "            self.assertTrue(os.path.exists(config_path))\n",
    "            \n",
    "            with open(config_path, 'r') as f:\n",
    "                config = json.load(f)\n",
    "                \n",
    "            loaded_individual = DHPCTIndividual.from_config(config)\n",
    "            self.assertEqual(loaded_individual.env_name, \"TestEnv\")\n",
    "            self.assertEqual(loaded_individual.gym_name, \"CartPole-v1\")\n",
    "            self.assertEqual(len(loaded_individual.levels), 2)\n",
    "        finally:\n",
    "            os.unlink(config_path)\n",
    "    \n",
    "    def test_run(self):\n",
    "        \"\"\"Test running the individual in environment\"\"\"\n",
    "        rewards = self.individual.run(episodes=1, render=False)\n",
    "        self.assertEqual(len(rewards), 1)\n",
    "        self.assertIsInstance(rewards[0], (int, float))\n",
    "    \n",
    "    def test_mate(self):\n",
    "        \"\"\"Test mating operation\"\"\"\n",
    "        other_individual = DHPCTIndividual(\n",
    "            env_name=\"OtherEnv\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={},\n",
    "            levels=[\n",
    "                {'units': 20},\n",
    "                {'units': 10}\n",
    "            ],\n",
    "            activation_funcs=['sigmoid', 'linear'],\n",
    "            weight_types=['he_uniform', 'he_normal']\n",
    "        )\n",
    "        \n",
    "        offspring = self.individual.mate(other_individual)\n",
    "        self.assertIsInstance(offspring, DHPCTIndividual)\n",
    "        self.assertIn(offspring.env_name, [\"TestEnv\", \"OtherEnv\"])\n",
    "        self.assertEqual(len(offspring.levels), 2)\n",
    "        \n",
    "    def test_mutate(self):\n",
    "        \"\"\"Test mutation operation\"\"\"\n",
    "        original_config = self.individual.config()\n",
    "        \n",
    "        # Use high mutation rate to ensure changes\n",
    "        self.individual.mutate(mutation_rate=1.0)\n",
    "        \n",
    "        mutated_config = self.individual.config()\n",
    "        self.assertNotEqual(original_config['levels'][0]['units'], \n",
    "                           mutated_config['levels'][0]['units'])\n",
    "    \n",
    "    def test_online_learning(self):\n",
    "        \"\"\"Test online learning functionality\"\"\"\n",
    "        # Compile model to prepare for learning\n",
    "        self.individual.compile()\n",
    "        \n",
    "        # Get original weights\n",
    "        original_weights = [layer.get_weights() for layer in self.individual.model.layers \n",
    "                           if len(layer.get_weights()) > 0]\n",
    "        \n",
    "        # Run with online learning\n",
    "        self.individual.run(episodes=2, online_learning=True, learning_rate=0.1)\n",
    "        \n",
    "        # Get new weights\n",
    "        new_weights = [layer.get_weights() for layer in self.individual.model.layers \n",
    "                      if len(layer.get_weights()) > 0]\n",
    "        \n",
    "        # Check if weights have changed (at least one layer should have different weights)\n",
    "        weights_changed = False\n",
    "        for i in range(len(original_weights)):\n",
    "            if not np.array_equal(original_weights[i][0], new_weights[i][0]):\n",
    "                weights_changed = True\n",
    "                break\n",
    "                \n",
    "        self.assertTrue(weights_changed)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "148396cc",
   "metadata": {},
   "source": [
    "## DHPCTEvolver Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "898d5184",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTEvolver(unittest.TestCase):\n",
    "    \"\"\"Test cases for DHPCTEvolver class\"\"\"\n",
    "    \n",
    "    def setUp(self):\n",
    "        \"\"\"Set up test fixtures\"\"\"\n",
    "        # Create a template individual\n",
    "        self.template = DHPCTIndividual(\n",
    "            env_name=\"TestEnv\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={},\n",
    "            levels=[\n",
    "                {'units': 10},\n",
    "                {'units': 5}\n",
    "            ],\n",
    "            activation_funcs=['relu', 'tanh'],\n",
    "            weight_types=['glorot_uniform', 'glorot_uniform']\n",
    "        )\n",
    "        \n",
    "        # Create evolver with small population for testing\n",
    "        self.evolver = DHPCTEvolver(\n",
    "            population_size=3,  # Small for quick tests\n",
    "            gens=2,             # Only 2 generations for quick tests\n",
    "            cx_prob=0.7,\n",
    "            mut_prob=0.2,\n",
    "            elite_size=1,\n",
    "            env_template=self.template\n",
    "        )\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        \"\"\"Test proper initialization of DHPCTEvolver\"\"\"\n",
    "        self.assertEqual(self.evolver.population_size, 3)\n",
    "        self.assertEqual(self.evolver.gens, 2)\n",
    "        self.assertEqual(self.evolver.cx_prob, 0.7)\n",
    "        self.assertEqual(self.evolver.mut_prob, 0.2)\n",
    "        self.assertEqual(self.evolver.elite_size, 1)\n",
    "        self.assertIsNotNone(self.evolver.env_template)\n",
    "        self.assertIsNone(self.evolver.toolbox)\n",
    "        self.assertIsNone(self.evolver.stats)\n",
    "        self.assertIsNone(self.evolver.logbook)\n",
    "    \n",
    "    def test_setup_evolution(self):\n",
    "        \"\"\"Test setup of evolution toolbox\"\"\"\n",
    "        self.evolver.setup_evolution(evaluation_episodes=1, mutation_rate=0.1)\n",
    "        self.assertIsNotNone(self.evolver.toolbox)\n",
    "        self.assertIsNotNone(self.evolver.stats)\n",
    "        self.assertIsNotNone(self.evolver.logbook)\n",
    "    \n",
    "    def test_run_evolution(self):\n",
    "        \"\"\"Test running evolution process\"\"\"\n",
    "        # Setup with minimal evaluation for speed\n",
    "        self.evolver.setup_evolution(evaluation_episodes=1, mutation_rate=0.1)\n",
    "        \n",
    "        # Run evolution\n",
    "        pop, log = self.evolver.run_evolution(verbose=False)\n",
    "        \n",
    "        # Check results\n",
    "        self.assertEqual(len(pop), 3)  # Population size\n",
    "        self.assertEqual(len(log), 3)  # Initial + 2 generations\n",
    "        self.assertIsNotNone(self.evolver.best_individual)\n",
    "        self.assertIsInstance(self.evolver.best_individual, DHPCTIndividual)\n",
    "    \n",
    "    def test_save_results(self):\n",
    "        \"\"\"Test saving evolution results\"\"\"\n",
    "        # Setup and run evolution\n",
    "        self.evolver.setup_evolution(evaluation_episodes=1, mutation_rate=0.1)\n",
    "        self.evolver.run_evolution(verbose=False)\n",
    "        \n",
    "        # Create temporary files for output\n",
    "        with tempfile.NamedTemporaryFile(suffix='.json', delete=False) as pop_file, \\\n",
    "             tempfile.NamedTemporaryFile(suffix='.json', delete=False) as log_file, \\\n",
    "             tempfile.NamedTemporaryFile(suffix='.json', delete=False) as best_file:\n",
    "             \n",
    "            pop_path = pop_file.name\n",
    "            log_path = log_file.name\n",
    "            best_path = best_file.name\n",
    "        \n",
    "        try:\n",
    "            # Save results\n",
    "            self.evolver.save_results(\n",
    "                population_file=pop_path,\n",
    "                logbook_file=log_path,\n",
    "                best_file=best_path\n",
    "            )\n",
    "            \n",
    "            # Check files exist and contain valid JSON\n",
    "            self.assertTrue(os.path.exists(pop_path))\n",
    "            self.assertTrue(os.path.exists(log_path))\n",
    "            self.assertTrue(os.path.exists(best_path))\n",
    "            \n",
    "            with open(pop_path, 'r') as f:\n",
    "                pop_data = json.load(f)\n",
    "                self.assertEqual(len(pop_data), 3)  # Population size\n",
    "                \n",
    "            with open(log_path, 'r') as f:\n",
    "                log_data = json.load(f)\n",
    "                self.assertIn('generations', log_data)\n",
    "                self.assertIn('avg', log_data)\n",
    "                \n",
    "            with open(best_path, 'r') as f:\n",
    "                best_data = json.load(f)\n",
    "                self.assertIn('env_name', best_data)\n",
    "                self.assertIn('levels', best_data)\n",
    "        finally:\n",
    "            # Clean up\n",
    "            for path in [pop_path, log_path, best_path]:\n",
    "                if os.path.exists(path):\n",
    "                    os.unlink(path)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4024dbaa",
   "metadata": {},
   "source": [
    "## DHPCTOptimizer Tests"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f9e2a101",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTOptimizer(unittest.TestCase):\n",
    "    \"\"\"Test cases for DHPCTOptimizer class\"\"\"\n",
    "    \n",
    "    def setUp(self):\n",
    "        \"\"\"Set up test fixtures\"\"\"\n",
    "        self.optimizer = DHPCTOptimizer(\n",
    "            env_name=\"TestEnv\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={},\n",
    "            n_trials=2,  # Minimal for testing\n",
    "            timeout=None,\n",
    "            db_storage=None\n",
    "        )\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        \"\"\"Test proper initialization of DHPCTOptimizer\"\"\"\n",
    "        self.assertEqual(self.optimizer.env_name, \"TestEnv\")\n",
    "        self.assertEqual(self.optimizer.gym_name, \"CartPole-v1\")\n",
    "        self.assertEqual(self.optimizer.n_trials, 2)\n",
    "        self.assertIsNone(self.optimizer.timeout)\n",
    "        self.assertIsNone(self.optimizer.db_storage)\n",
    "        self.assertIsNone(self.optimizer.study)\n",
    "        self.assertIsNone(self.optimizer.best_params)\n",
    "    \n",
    "    def test_objective_function(self):\n",
    "        \"\"\"Test the objective function definition\"\"\"\n",
    "        # Create a mock trial for testing\n",
    "        trial = optuna.trial.FixedTrial({\n",
    "            'n_levels': 2,\n",
    "            'level_0_units': 10,\n",
    "            'level_0_activation': 'relu',\n",
    "            'level_0_weight': 'glorot_uniform',\n",
    "            'level_1_units': 5,\n",
    "            'level_1_activation': 'tanh',\n",
    "            'level_1_weight': 'glorot_uniform'\n",
    "        })\n",
    "        \n",
    "        # Set evaluation episodes to 1 for speed\n",
    "        self.optimizer.evaluation_episodes = 1\n",
    "        \n",
    "        # Test objective function\n",
    "        fitness = self.optimizer.define_objective(trial)\n",
    "        self.assertIsInstance(fitness, (int, float))\n",
    "    \n",
    "    def test_run_optimization(self):\n",
    "        \"\"\"Test running optimization process\"\"\"\n",
    "        # Run optimization with minimal evaluation for speed\n",
    "        study = self.optimizer.run_optimization(evaluation_episodes=1, verbose=False)\n",
    "        \n",
    "        # Check results\n",
    "        self.assertIsNotNone(study)\n",
    "        self.assertEqual(len(study.trials), 2)  # n_trials\n",
    "        self.assertIsNotNone(self.optimizer.best_params)\n",
    "        self.assertIn('n_levels', self.optimizer.best_params)\n",
    "    \n",
    "    def test_get_best_individual(self):\n",
    "        \"\"\"Test getting best individual from optimization\"\"\"\n",
    "        # Run optimization first\n",
    "        self.optimizer.run_optimization(evaluation_episodes=1, verbose=False)\n",
    "        \n",
    "        # Get best individual\n",
    "        individual = self.optimizer.get_best_individual()\n",
    "        \n",
    "        # Check results\n",
    "        self.assertIsInstance(individual, DHPCTIndividual)\n",
    "        self.assertEqual(individual.env_name, \"TestEnv\")\n",
    "        self.assertEqual(individual.gym_name, \"CartPole-v1\")\n",
    "        \n",
    "        # Number of levels should match the optimized parameter\n",
    "        n_levels = self.optimizer.best_params['n_levels']\n",
    "        self.assertEqual(len(individual.levels), n_levels)\n",
    "    \n",
    "    def test_save_results(self):\n",
    "        \"\"\"Test saving optimization results\"\"\"\n",
    "        # Run optimization first\n",
    "        self.optimizer.run_optimization(evaluation_episodes=1, verbose=False)\n",
    "        \n",
    "        # Create temporary files for output\n",
    "        with tempfile.NamedTemporaryFile(suffix='.json', delete=False) as params_file, \\\n",
    "             tempfile.NamedTemporaryFile(suffix='.json', delete=False) as ind_file:\n",
    "             \n",
    "            params_path = params_file.name\n",
    "            ind_path = ind_file.name\n",
    "        \n",
    "        try:\n",
    "            # Save results\n",
    "            self.optimizer.save_results(\n",
    "                best_params_file=params_path,\n",
    "                best_individual_file=ind_path\n",
    "            )\n",
    "            \n",
    "            # Check files exist and contain valid JSON\n",
    "            self.assertTrue(os.path.exists(params_path))\n",
    "            self.assertTrue(os.path.exists(ind_path))\n",
    "            \n",
    "            with open(params_path, 'r') as f:\n",
    "                params_data = json.load(f)\n",
    "                self.assertIn('n_levels', params_data)\n",
    "                \n",
    "            with open(ind_path, 'r') as f:\n",
    "                ind_data = json.load(f)\n",
    "                self.assertIn('env_name', ind_data)\n",
    "                self.assertIn('levels', ind_data)\n",
    "        finally:\n",
    "            # Clean up\n",
    "            for path in [params_path, ind_path]:\n",
    "                if os.path.exists(path):\n",
    "                    os.unlink(path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa8a503b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run the tests\n",
    "unittest.main(argv=['first-arg-is-ignored'], exit=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c441977",
   "metadata": {},
   "source": [
    "# DPCT Unit Tests\n",
    "\n",
    "> Unit tests for the Deep Perceptual Control Theory library components."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f1a3da1f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "sys.path.append(\"..\")\n",
    "import json\n",
    "import unittest\n",
    "import numpy as np\n",
    "import tensorflow as tf\n",
    "import gym\n",
    "import optuna"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "267f52ed",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import DPCT components\n",
    "from dpct.individual import DHPCTIndividual\n",
    "from dpct.evolver import DHPCTEvolver\n",
    "from dpct.optimizer import DHPCTOptimizer"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4220c90c",
   "metadata": {},
   "source": [
    "## Test DHPCTIndividual"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "390e359e",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTIndividual(unittest.TestCase):\n",
    "    \n",
    "    def setUp(self):\n",
    "        # Create a test individual\n",
    "        self.individual = DHPCTIndividual(\n",
    "            env_name=\"CartPole\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={\"render_mode\": \"rgb_array\"},\n",
    "            levels=[4, 3, 2]\n",
    "        )\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        self.assertEqual(self.individual.env_name, \"CartPole\")\n",
    "        self.assertEqual(self.individual.gym_name, \"CartPole-v1\")\n",
    "        self.assertEqual(self.individual.env_props, {\"render_mode\": \"rgb_array\"})\n",
    "        self.assertEqual(self.individual.levels, [4, 3, 2])\n",
    "        self.assertEqual(self.individual.weight_types, {\"all\": \"float\"})\n",
    "    \n",
    "    def test_compile(self):\n",
    "        self.individual.compile()\n",
    "        self.assertIsNotNone(self.individual.env)\n",
    "        self.assertIsNotNone(self.individual.model)\n",
    "        \n",
    "    def test_config(self):\n",
    "        config = self.individual.config()\n",
    "        self.assertIn(\"env\", config)\n",
    "        self.assertIn(\"hierarchy\", config)\n",
    "        self.assertIn(\"weights\", config)\n",
    "        self.assertEqual(config[\"env\"][\"name\"], \"CartPole\")\n",
    "        self.assertEqual(config[\"hierarchy\"][\"levels\"], [4, 3, 2])\n",
    "    \n",
    "    def test_from_config(self):\n",
    "        # Create a config\n",
    "        config = self.individual.config()\n",
    "        \n",
    "        # Create a new individual from config\n",
    "        new_individual = DHPCTIndividual.from_config(config)\n",
    "        \n",
    "        # Check if properties match\n",
    "        self.assertEqual(new_individual.env_name, self.individual.env_name)\n",
    "        self.assertEqual(new_individual.gym_name, self.individual.gym_name)\n",
    "        self.assertEqual(new_individual.levels, self.individual.levels)\n",
    "    \n",
    "    def test_save_config(self):\n",
    "        # Save config to a temporary file\n",
    "        result = self.individual.save_config(\"temp_config.json\")\n",
    "        self.assertTrue(result)\n",
    "        \n",
    "        # Load the config file and check contents\n",
    "        with open(\"temp_config.json\", \"r\") as f:\n",
    "            loaded_config = json.load(f)\n",
    "        \n",
    "        self.assertEqual(loaded_config[\"env\"][\"name\"], \"CartPole\")\n",
    "    \n",
    "    def test_run(self):\n",
    "        self.individual.compile()\n",
    "        reward = self.individual.run(steps=10, early_termination=True)\n",
    "        self.assertIsInstance(reward, (int, float))\n",
    "    \n",
    "    def test_run_with_training(self):\n",
    "        self.individual.compile()\n",
    "        reward = self.individual.run(steps=10, train=True, early_termination=True)\n",
    "        self.assertIsInstance(reward, (int, float))\n",
    "    \n",
    "    def test_mate(self):\n",
    "        # Create another individual\n",
    "        other_individual = DHPCTIndividual(\n",
    "            env_name=\"CartPole\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={\"render_mode\": \"rgb_array\"},\n",
    "            levels=[4, 3, 3]\n",
    "        )\n",
    "        \n",
    "        # Mate individuals\n",
    "        child1, child2 = self.individual.mate(other_individual)\n",
    "        \n",
    "        # Check that children are DHPCTIndividuals\n",
    "        self.assertIsInstance(child1, DHPCTIndividual)\n",
    "        self.assertIsInstance(child2, DHPCTIndividual)\n",
    "    \n",
    "    def test_mutate(self):\n",
    "        # Get initial levels\n",
    "        initial_levels = self.individual.levels.copy()\n",
    "        \n",
    "        # Force a structure mutation\n",
    "        np.random.seed(42)  # For reproducibility\n",
    "        self.individual.mutate(struct_prob=1.0, weight_prob=0.0)\n",
    "        \n",
    "        # Check that levels have changed\n",
    "        self.assertNotEqual(self.individual.levels, initial_levels)\n",
    "    \n",
    "    def test_evaluate(self):\n",
    "        self.individual.compile()\n",
    "        fitness = self.individual.evaluate(nevals=2)\n",
    "        self.assertIsInstance(fitness, (int, float))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e9052b32",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run the tests\n",
    "unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(TestDHPCTIndividual))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7ebd5176",
   "metadata": {},
   "source": [
    "## Test DHPCTEvolver"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "28e19b64",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTEvolver(unittest.TestCase):\n",
    "    \n",
    "    def setUp(self):\n",
    "        # Create a test individual\n",
    "        self.individual = DHPCTIndividual(\n",
    "            env_name=\"CartPole\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={\"render_mode\": \"rgb_array\"},\n",
    "            levels=[4, 3, 2]\n",
    "        )\n",
    "        \n",
    "        # Create a test evolver\n",
    "        self.evolver = DHPCTEvolver(\n",
    "            pop_size=5,  # Small population for testing\n",
    "            generations=2,  # Few generations for testing\n",
    "            run_best=False,\n",
    "            save_arch_best=False\n",
    "        )\n",
    "        \n",
    "        # Define a simple fitness function\n",
    "        def fitness_function(individual):\n",
    "            # Return a random fitness for testing\n",
    "            return np.random.random()\n",
    "        \n",
    "        self.fitness_function = fitness_function\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        self.assertEqual(self.evolver.pop_size, 5)\n",
    "        self.assertEqual(self.evolver.generations, 2)\n",
    "        self.assertFalse(self.evolver.run_best)\n",
    "    \n",
    "    def test_setup_evolution(self):\n",
    "        self.evolver.setup_evolution(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function\n",
    "        )\n",
    "        self.assertIsNotNone(self.evolver.toolbox)\n",
    "        self.assertIsNotNone(self.evolver.stats)\n",
    "        self.assertIsNotNone(self.evolver.hof)\n",
    "    \n",
    "    def test_run_evolution(self):\n",
    "        self.evolver.setup_evolution(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function,\n",
    "            minimize=True\n",
    "        )\n",
    "        \n",
    "        population, logbook, hof = self.evolver.run_evolution(verbose=False)\n",
    "        \n",
    "        self.assertEqual(len(population), 5)  # Check population size\n",
    "        self.assertEqual(len(logbook), 3)  # Initial + 2 generations\n",
    "        self.assertEqual(len(hof), 1)  # Hall of fame size\n",
    "    \n",
    "    def test_save_results(self):\n",
    "        # Setup and run evolution\n",
    "        self.evolver.setup_evolution(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function\n",
    "        )\n",
    "        self.evolver.run_evolution(verbose=False)\n",
    "        \n",
    "        # Save results\n",
    "        self.evolver.save_results(\"test_evolution\")\n",
    "        \n",
    "        # Check that files were created (minimal check)\n",
    "        import os\n",
    "        self.assertTrue(os.path.exists(\"test_evolution_stats.json\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "192063e4",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run the tests\n",
    "unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(TestDHPCTEvolver))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "07fbde27",
   "metadata": {},
   "source": [
    "## Test DHPCTOptimizer"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "57a200c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "class TestDHPCTOptimizer(unittest.TestCase):\n",
    "    \n",
    "    def setUp(self):\n",
    "        # Create a test individual\n",
    "        self.individual = DHPCTIndividual(\n",
    "            env_name=\"CartPole\",\n",
    "            gym_name=\"CartPole-v1\",\n",
    "            env_props={\"render_mode\": \"rgb_array\"},\n",
    "            levels=[4, 3, 2]\n",
    "        )\n",
    "        \n",
    "        # Define evolution parameters for optimization\n",
    "        self.evolution_params = {\n",
    "            \"pop_size\": {\"fixed\": False, \"type\": \"int\", \"min\": 3, \"max\": 5},\n",
    "            \"generations\": {\"fixed\": True, \"value\": 2},\n",
    "            \"minimize\": {\"fixed\": True, \"value\": True}\n",
    "        }\n",
    "        \n",
    "        # Create a test optimizer\n",
    "        self.optimizer = DHPCTOptimizer(\n",
    "            evolution_params=self.evolution_params,\n",
    "            n_trials=2  # Few trials for testing\n",
    "        )\n",
    "        \n",
    "        # Define a simple fitness function\n",
    "        def fitness_function(individual):\n",
    "            # Return a random fitness for testing\n",
    "            return np.random.random()\n",
    "        \n",
    "        self.fitness_function = fitness_function\n",
    "    \n",
    "    def test_initialization(self):\n",
    "        self.assertEqual(self.optimizer.evolution_params, self.evolution_params)\n",
    "        self.assertEqual(self.optimizer.n_trials, 2)\n",
    "        self.assertIsNone(self.optimizer.timeout)\n",
    "    \n",
    "    def test_define_objective(self):\n",
    "        self.optimizer.define_objective(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function,\n",
    "            evaluation_budget=2\n",
    "        )\n",
    "        \n",
    "        self.assertIsNotNone(self.optimizer._objective_func)\n",
    "        self.assertEqual(self.optimizer._template_individual, self.individual)\n",
    "        self.assertEqual(self.optimizer._fitness_function, self.fitness_function)\n",
    "        self.assertEqual(self.optimizer._evaluation_budget, 2)\n",
    "    \n",
    "    def test_run_optimization(self):\n",
    "        self.optimizer.define_objective(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function,\n",
    "            evaluation_budget=2\n",
    "        )\n",
    "        \n",
    "        study = self.optimizer.run_optimization(verbose=False)\n",
    "        \n",
    "        self.assertIsNotNone(study)\n",
    "        self.assertEqual(len(study.trials), 2)  # Two trials\n",
    "        self.assertIsNotNone(study.best_trial)\n",
    "    \n",
    "    def test_get_best_params(self):\n",
    "        self.optimizer.define_objective(\n",
    "            template_individual=self.individual,\n",
    "            fitness_function=self.fitness_function\n",
    "        )\n",
    "        \n",
    "        self.optimizer.run_optimization(verbose=False)\n",
    "        best_params = self.optimizer.get_best_params()\n",
    "        \n",
    "        self.assertIn(\"pop_size\", best_params)\n",
    "        self.assertIn(\"generations\", best_params)\n",
    "        self.assertEqual(best_params[\"generations\"], 2)  # Fixed value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "699fbb97",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Run the tests\n",
    "unittest.TextTestRunner().run(unittest.TestLoader().loadTestsFromTestCase(TestDHPCTOptimizer))"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
